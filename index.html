<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pac-Man Game</title>
    <style>
        body{
            background-color: rgb(110, 21, 98);
        }
        canvas {
            background-color: black;
            display: block;
            margin: 0 auto;
        }
        /* Стили для модального окна */
        #winModal {
            display: none; /* Скрываем по умолчанию */
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            text-align: center;
            z-index: 1000;
        }
        #winModal button {
            margin-top: 10px;
            padding: 10px 20px;
            background-color: blue;
            color: white;
            border: none;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="722" height="836"></canvas> <!-- 19*38 (width), 22*38 (height) -->
    
    <!-- Модальное окно для победы -->
    <div id="winModal">
        <h1>Победа!</h1>
        <p>Вы съели все монетки!</p>
        <button id="restartButton">Начать заново</button>
    </div>

    <script>

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const tileSize = 38;  // Размер одной клетки 38x38
        const numRows = 9;   // Количество клеток по высоте
        const numCols = 19;   // Количество клеток по ширине

        let score = 0; // Счётчик съеденных монеток
        let totalCoins = 0; // Общее количество монеток

        // Лабиринт, где 1 — стена, 0 — пустая клетка, 2 — монетка
        const maze = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],
            [1, 2, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 2, 1],
            [1, 2, 1, 2, 2, 2, 1, 2, 2, 2, 1, 2, 2, 2, 1, 2, 1, 2, 1],
            [3, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 4],
            [1, 2, 2, 2, 1, 2, 2, 2, 1, 2, 2, 2, 1, 2, 2, 2, 1, 2, 1],
            [1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1],
            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ];

        let lastTeleportTime = 0; // Переменная для отслеживания времени телепорта

        const teleportCooldown = 500; // Задержка перед следующим телепортом в миллисекундах
        // 1. Загружаем изображения призраков
        const ghostImages = [
            new Image(),
            new Image(),
            new Image()
        ];

        ghostImages[0].src = 'Group 114.png';
        ghostImages[1].src = 'Group 115.png';
        ghostImages[2].src = 'Group 116.png';

        // 2. Определяем призраков
        const ghosts = [
            { x: 1, y: 5, image: ghostImages[0] }, // Призрак 1
            { x: 5, y: 5, image: ghostImages[1] }, // Призрак 2
            { x: 7, y: 5, image: ghostImages[2] }  // Призрак 3
        ];

        const originalGhostPositions = [
            { x: 1, y: 5 },
            { x: 5, y: 5 },
            { x: 7, y: 5 }
        ];

        const ghostSpeed = 600; // Задержка между движениями призраков (в миллисекундах)
        let lastGhostMoveTime = 0;


        // 3. Логика движения призраков
        function moveGhosts(timestamp) {
            if (timestamp - lastGhostMoveTime > ghostSpeed) {
                ghosts.forEach(ghost => {
                    // Генерируем случайное направление
                    const direction = Math.floor(Math.random() * 4);
                    let nextX = ghost.x;
                    let nextY = ghost.y;

                    if (direction === 0) nextY--; // Вверх
                    else if (direction === 1) nextY++; // Вниз
                    else if (direction === 2) nextX--; // Влево
                    else if (direction === 3) nextX++; // Вправо

                    // Проверяем, можно ли двигаться
                    if (!isWall(nextX, nextY)) {
                        ghost.x = nextX;
                        ghost.y = nextY;
                    }

                    checkGhostTeleport(ghost); // Проверка телепортации для призрака
                });
                lastGhostMoveTime = timestamp; // Обновляем время последнего движения призраков
            }
        }


        // 2. Обновим проверку телепортации для призраков
        function checkGhostTeleport(ghost) {
            const currentTime = Date.now();
            
            if (currentTime - lastTeleportTime < teleportCooldown) return; // Проверяем задержку

            if (maze[ghost.y][ghost.x] === 3) {
                ghost.x = 18; // Телепортируем на клетку с телепортом 4
                ghost.y = 4;
                lastTeleportTime = currentTime; // Обновляем время последнего телепорта
            } else if (maze[ghost.y][ghost.x] === 4) {
                ghost.x = 0; // Телепортируем на клетку с телепортом 3
                ghost.y = 4;
                lastTeleportTime = currentTime; // Обновляем время последнего телепорта
            }
        }

        let gameOver = false; // Add a game over flag

        function checkGhostCollision() {
            ghosts.forEach(ghost => {
                if (ghost.x === player.x && ghost.y === player.y) {
                    gameOver = true; // Set game over flag to true
                    player.x = 1; // Reset player position
                    player.y = 1;
                    ghosts.forEach((ghost, index) => {
                        ghost.x = originalGhostPositions[index].x;
                        ghost.y = originalGhostPositions[index].y;
                    });
                    showGameOverModal(); // Show Game Over modal
                }
            });
        }

        // 2. Убедитесь, что в функции showGameOverModal используется правильный контекст для удаления окна
        function showGameOverModal() {
            const gameOverModal = document.createElement('div');
            gameOverModal.innerHTML = `
                <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); z-index: 1000;">
                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; text-align: center;">
                        <h1>Игра окончена!</h1>
                        <button onclick="restartGame()">Начать заново</button>
                    </div>
                </div>
            `;
            document.body.appendChild(gameOverModal);
        }

        function restartGame() {
            score = 0;
            gameOver = false;
            player.x = 1;
            player.y = 1;
            ghosts.forEach((ghost, index) => {
                ghost.x = originalGhostPositions[index].x;
                ghost.y = originalGhostPositions[index].y;
            });
            hideGameOverModal();
            draw();
        }

        function hideGameOverModal() {
            const gameOverModal = document.querySelector('div[style*="background: rgba(0, 0, 0, 0.8);"]');
            if (gameOverModal) {
                document.body.removeChild(gameOverModal);
            }
        }

        const player = {
            x: 1,
            y: 1,
            direction: { x: 0, y: 0 }
        };

        function isWall(x, y) {
            return maze[y][x] === 1; // Проверяем, является ли клетка стеной
        }

        // Рисуем элементы на канвасе
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for (let row = 0; row < maze.length; row++) {
                for (let col = 0; col < maze[row].length; col++) {
                    if (maze[row][col] === 1) {
                        ctx.fillStyle = 'blue'; // Цвет стен
                        ctx.fillRect(col * tileSize, row * tileSize, tileSize, tileSize);
                    } else if (maze[row][col] === 2) {
                        ctx.fillStyle = 'yellow'; // Цвет монет
                        ctx.beginPath();
                        ctx.arc(col * tileSize + tileSize / 2, row * tileSize + tileSize / 2, 10, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            // Рисуем игрока
            ctx.fillStyle = 'yellow';
            ctx.beginPath();
            ctx.arc(player.x * tileSize + tileSize / 2, player.y * tileSize + tileSize / 2, 15, 0, Math.PI * 2);
            ctx.fill();

            // Рисуем призраков
            ghosts.forEach(ghost => {
                ctx.drawImage(ghost.image, ghost.x * tileSize, ghost.y * tileSize, tileSize, tileSize);
            });

            // Проверяем столкновения с монетками
            checkCoinCollision();

            // Проверяем столкновения с призраками
            checkGhostCollision();

            if (gameOver) return; // Если игра окончена, прекращаем выполнение
            requestAnimationFrame(draw); // Запрашиваем следующую анимацию
        }

        function checkCoinCollision() {
            if (maze[player.y][player.x] === 2) {
                maze[player.y][player.x] = 0; // Удаляем монету
                score++;
                totalCoins++;
                if (score === totalCoins) {
                    showWinModal(); // Показываем окно победы
                }
            }
        }

        function showWinModal() {
            document.getElementById('winModal').style.display = 'block'; // Показываем модальное окно
        }

        // Условие для повторного запуска игры
        document.getElementById('restartButton').addEventListener('click', () => {
            document.getElementById('winModal').style.display = 'none';
            restartGame();
        });

        // 3. Обработчик события для клавиатуры
        window.addEventListener('keydown', (e) => {
            switch (e.key) {
                case 'ArrowUp':
                    player.direction.y = -1;
                    break;
                case 'ArrowDown':
                    player.direction.y = 1;
                    break;
                case 'ArrowLeft':
                    player.direction.x = -1;
                    break;
                case 'ArrowRight':
                    player.direction.x = 1;
                    break;
            }
        });

        // 1. Добавляем обработчики событий для мобильных устройств
        let touchStartX = 0;
        let touchStartY = 0;

        window.addEventListener('touchstart', (e) => {
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
        });

        window.addEventListener('touchend', (e) => {
            const touch = e.changedTouches[0];
            const touchEndX = touch.clientX;
            const touchEndY = touch.clientY;

            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;

            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                // Горизонтальный свайп
                if (deltaX > 0) {
                    player.direction.x = 1; // Вправо
                    player.direction.y = 0;
                } else {
                    player.direction.x = -1; // Влево
                    player.direction.y = 0;
                }
            } else {
                // Вертикальный свайп
                if (deltaY > 0) {
                    player.direction.y = 1; // Вниз
                    player.direction.x = 0;
                } else {
                    player.direction.y = -1; // Вверх
                    player.direction.x = 0;
                }
            }
        });

        // Основной игровой цикл
        setInterval(() => {
            // Перемещаем игрока
            const nextX = player.x + player.direction.x;
            const nextY = player.y + player.direction.y;

            // Проверяем возможность перемещения
            if (!isWall(nextX, nextY)) {
                player.x = nextX;
                player.y = nextY;
            }

            // Проверяем телепортацию
            checkTeleport();
        }, 200); // Обновляем игру каждые 200 мс

        // Проверяем, попадает ли игрок в телепорт
        function checkTeleport() {
            if (maze[player.y][player.x] === 3) {
                player.x = 18; // Телепортируем на клетку с телепортом 4
                player.y = 4;
            } else if (maze[player.y][player.x] === 4) {
                player.x = 0; // Телепортируем на клетку с телепортом 3
                player.y = 4;
            }
        }

        // Запускаем игру
        draw();
    </script>
</body>
</html>
